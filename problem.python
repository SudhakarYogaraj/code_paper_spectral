#include "Problem.hpp"
#include "templates.hpp"
#include "Gaussian_integrator.hpp"
#include "toolbox.hpp"
#include "io.hpp"
#include "global.hpp"

using namespace std;

void Problem::init() {

    this->t_end = 1.;
    this->nf = 2;
    this->ns = 2;
    this->x0 = vector<double>(ns,1.2);
    this->bias = vector<double>(nf, 0.);
    this->eig_val_cov = vector<double>(nf, 1.);
    this->sqrt_cov = vector< vector<double> > (nf, vector<double> (nf,0.));
    this->covariance = vector< vector<double> > (nf, vector<double> (nf,0.));
    this->eig_vec_cov = vector< vector<double> > (nf, vector<double> (nf,0.));
    this->inv_cov = vector< vector<double> > (nf, vector<double> (nf,0.));
    this->det_sqrt_cov = 1.;
    for (int i = 0; i < nf; ++i) {
        sqrt_cov[i][i] = 1.;
        eig_vec_cov[i][i] = 1.;
    }

    dyv = vector<double (*) (vector<double> x, vector<double> y)> (nf);
    h = vector<double (*) (vector<double> x, vector<double> y)> (nf);
    a = vector<double (*) (vector<double> x, vector<double> y)> (ns);
    dxa = vector< vector<double (*) (vector<double> x, vector<double> y)> >(ns, vector<double (*) (vector<double> x, vector<double> y)> (ns));
    dya = vector< vector<double (*) (vector<double> x, vector<double> y)> >(ns, vector<double (*) (vector<double> x, vector<double> y)> (nf));
    phi = vector<double (*) (vector<double> x, vector<double> y)> (ns);
    dxphi = vector< vector<double (*) (vector<double> x, vector<double> y)> >(ns, vector<double (*) (vector<double> x, vector<double> y)> (ns));
    drif = vector<double (*) (vector<double> x, vector<double> y)> (2*nf);
    diff = vector<double (*) (vector<double> x, vector<double> y)> (2*nf);

    this->init_functions();
    Gaussian_integrator gauss = Gaussian_integrator(100, nf);
    auto lambda = [&] (vector<double> y) -> double {
        return rho(x0,y)/gaussian(y);
    };
    cout << "Normalizing constant: " << gauss.quadnd(lambda) << endl;
}

// Calculation of the sqrt_cov and mean of the invariant measure.
// The outer loop serves to obtain a more accurate result.
void Problem::update_stats(vector<double> x) {

    Gaussian_integrator gauss = Gaussian_integrator(30, nf);

    int n_iterations = 5, i = 0;
    for (int n = 0; n < n_iterations; ++n) {

        // Calculation of the bias of 'rho'
        bias = vector<double> (nf, 0.);
        for (i = 0; i < nf; ++i) {
            auto lambda = [&] (vector<double> z) -> double {
                vector<double> y = rescale(z);
                return det_sqrt_cov * y[i] * (rho(x,y)/gaussian(z));
            };
            bias[i] = gauss.quadnd(lambda);
        }

        // Calculation of the covariance matrix
        for (i = 0; i < nf; ++i) {
            for (int j = 0; j < nf; ++j) {
                auto lambda = [&] (vector<double> z) -> double {
                    vector<double> y = rescale(z);
                    return det_sqrt_cov * (y[i] - bias[i]) * (y[j] - bias[j]) * (rho(x,y)/gaussian(z));
                };
                covariance[i][j] = gauss.quadnd(lambda);
            }
        }

        // Eigenvalue decomposition
        eig_qr(covariance, eig_vec_cov, eig_val_cov);

        sqrt_cov = eig_vec_cov;
        for (int i = 0; i < nf; i++) {
            for (int j = 0; j < nf; j++) {
                sqrt_cov[i][j] *= sqrt(eig_val_cov[j]);
            }
        }

        // Determinant of sqrt_cov
        for (det_sqrt_cov = 1., i = 0; i < nf; ++i)
            det_sqrt_cov *= sqrt(eig_val_cov[i]);

        // Inverse of covariance matrix
        for (int i = 0; i < nf; ++i) {
            vector<double> rhs_tmp(nf, 0.); rhs_tmp[i] = 1.;
            inv_cov[i] = solve(covariance, rhs_tmp);
        }
        inv_cov = transpose(inv_cov);
    }

    if(DEBUG) {
        cout << endl << "* Covariance matrix of the invariant density" << endl;
        niceMat(covariance);

        cout << endl << "* Inverse of the covariance matrix" << endl;
        niceMat(inv_cov);

        cout << endl << "* Bias of the invariant density" << endl;
        niceVec(bias);

        cout << endl << "* Eigenvectors of the covariance matrix" << endl;
        niceMat(eig_vec_cov);
    }
}

vector<double> Problem::rescale(vector<double> y) {
    vector<double> result(y.size(), 0.);
    for (int i = 0; i < y.size(); ++i) { for (int j = 0; j < y.size(); ++j) {
            result[i] += sqrt_cov[i][j] * y[j];
        }
    }
    return (result + bias);
}

vector<double> Problem::soldrif(vector<double> x) {
    vector<double> result(this->ns,0.);
    Gaussian_integrator gauss = Gaussian_integrator(100,this->nf);
    auto lambda = [&] (vector<double> z) -> vector<double> {
        vector<double> y = rescale(z);
        vector<double> tmp(ns, 0.);
        for (int i = 0; i < ns; ++i) {
            for (int j = 0; j < ns; ++j) {
                tmp[i] += dxphi[i][j](x,y) * a[j](x,y) + phi[i](x,y) * stardiv_h(x,y);
            }
        }
        return tmp*(rho(x,y)/gaussian(z));
    };
    result = gauss.quadnd(lambda, result) * det_sqrt_cov;
    return result;
}

vector< vector<double> > Problem::soldiff(vector<double> x) {
    Gaussian_integrator gauss = Gaussian_integrator(100,this->nf);
    vector< vector<double> > result(this->ns,vector<double>(this->ns,0.));
    auto lambda = [&] (vector<double> z) -> vector< vector<double> > {
        vector<double> y = rescale(z);
        vector< vector<double> > tens_prod(this->ns, vector<double>(this->ns, 0.));
        for (int i = 0; i < this->ns; ++i) {
            for (int j = 0; j < this->ns; ++j) {
                tens_prod[i][j] = 2*a[i](x,y)*phi[j](x,y)*(rho(x,y)/gaussian(z));
            }
        }
        return tens_prod;
    };
    result = cholesky(symmetric( gauss.quadnd(lambda, result) * det_sqrt_cov ));
    return result;
}
double stardiv_h_n(vector<double> x, vector<double> y){
    double result = 0*(0.1*y[0] + 1.0*y[1] - 1.1) + 0*(0.1*y[1] + 2.0*pow(y[0] - 1, 3) - 0.1);
    return result; 
}

double potential_n(vector<double> x, vector<double> y){
    double result = 0.5*(0.2*y[0] - 0.2)*(y[1] - 1) + 0.5*pow(y[0] - 1, 4) + 0.5*pow(y[1] - 1, 2);
    return result; 
}

double linearTerm_n(vector<double> x, vector<double> y){
    double result = 3.0*pow(y[0] - 1, 2) - 0.25*pow(0.1*y[0] + 1.0*y[1] - 1.1, 2) - 0.25*pow(0.1*y[1] + 2.0*pow(y[0] - 1, 3) - 0.1, 2) + 0.5;
    return result; 
}

double rho_n(vector<double> x, vector<double> y){
    double result = 0.184612911708567*exp(-0.5*(0.2*y[0] - 0.2)*(y[1] - 1) - 0.5*pow(y[0] - 1, 4) - 0.5*pow(y[1] - 1, 2));
    return result; 
}

double phi0(vector<double> x, vector<double> y){
    double result = sin(y[0]*y[1])*cos(x[0]);
    return result; 
}

double a0(vector<double> x, vector<double> y){
    double result = (-2.0*pow(y[0], 3)*y[1]*cos(y[0]*y[1]) + 6.0*pow(y[0], 2)*y[1]*cos(y[0]*y[1]) - 1.0*pow(y[0], 2)*sin(y[0]*y[1]) - 0.1*pow(y[0], 2)*cos(y[0]*y[1]) - 7.0*y[0]*y[1]*cos(y[0]*y[1]) + 1.1*y[0]*cos(y[0]*y[1]) - 1.0*pow(y[1], 2)*sin(y[0]*y[1]) - 0.1*pow(y[1], 2)*cos(y[0]*y[1]) + 2.1*y[1]*cos(y[0]*y[1]))*cos(x[0]);
    return result; 
}

double dxphi00(vector<double> x, vector<double> y){
    double result = -sin(x[0] + x[1])*sin(y[0] + y[1]);
    return result; 
}

double dxa00(vector<double> x, vector<double> y){
    double result = -(-2.0*pow(y[0], 3)*cos(y[0] + y[1]) + 6.0*pow(y[0], 2)*cos(y[0] + y[1]) - 6.1*y[0]*cos(y[0] + y[1]) - 1.1*y[1]*cos(y[0] + y[1]) - 2.0*sin(y[0] + y[1]) + 3.2*cos(y[0] + y[1]))*sin(x[0] + x[1]);
    return result; 
}

double dxphi01(vector<double> x, vector<double> y){
    double result = -sin(x[0] + x[1])*sin(y[0] + y[1]);
    return result; 
}

double dxa01(vector<double> x, vector<double> y){
    double result = -(-2.0*pow(y[0], 3)*cos(y[0] + y[1]) + 6.0*pow(y[0], 2)*cos(y[0] + y[1]) - 6.1*y[0]*cos(y[0] + y[1]) - 1.1*y[1]*cos(y[0] + y[1]) - 2.0*sin(y[0] + y[1]) + 3.2*cos(y[0] + y[1]))*sin(x[0] + x[1]);
    return result; 
}

double dya00(vector<double> x, vector<double> y){
    double result = (2.0*pow(y[0], 3)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*cos(y[0] + y[1]) + 6.1*y[0]*sin(y[0] + y[1]) + 12.0*y[0]*cos(y[0] + y[1]) + 1.1*y[1]*sin(y[0] + y[1]) - 3.2*sin(y[0] + y[1]) - 8.1*cos(y[0] + y[1]))*cos(x[0] + x[1]);
    return result; 
}

double dya01(vector<double> x, vector<double> y){
    double result = (2.0*pow(y[0], 3)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*sin(y[0] + y[1]) + 6.1*y[0]*sin(y[0] + y[1]) + 1.1*y[1]*sin(y[0] + y[1]) - 3.2*sin(y[0] + y[1]) - 3.1*cos(y[0] + y[1]))*cos(x[0] + x[1]);
    return result; 
}

double phi1(vector<double> x, vector<double> y){
    double result = sin(y[0] + y[1])*cos(x[0] + x[1]);
    return result; 
}

double a1(vector<double> x, vector<double> y){
    double result = (-2.0*pow(y[0], 3)*cos(y[0] + y[1]) + 6.0*pow(y[0], 2)*cos(y[0] + y[1]) - 6.1*y[0]*cos(y[0] + y[1]) - 1.1*y[1]*cos(y[0] + y[1]) - 2.0*sin(y[0] + y[1]) + 3.2*cos(y[0] + y[1]))*cos(x[0] + x[1]);
    return result; 
}

double dxphi10(vector<double> x, vector<double> y){
    double result = -sin(x[0] + x[1])*sin(y[0] + y[1]);
    return result; 
}

double dxa10(vector<double> x, vector<double> y){
    double result = -(-2.0*pow(y[0], 3)*cos(y[0] + y[1]) + 6.0*pow(y[0], 2)*cos(y[0] + y[1]) - 6.1*y[0]*cos(y[0] + y[1]) - 1.1*y[1]*cos(y[0] + y[1]) - 2.0*sin(y[0] + y[1]) + 3.2*cos(y[0] + y[1]))*sin(x[0] + x[1]);
    return result; 
}

double dxphi11(vector<double> x, vector<double> y){
    double result = -sin(x[0] + x[1])*sin(y[0] + y[1]);
    return result; 
}

double dxa11(vector<double> x, vector<double> y){
    double result = -(-2.0*pow(y[0], 3)*cos(y[0] + y[1]) + 6.0*pow(y[0], 2)*cos(y[0] + y[1]) - 6.1*y[0]*cos(y[0] + y[1]) - 1.1*y[1]*cos(y[0] + y[1]) - 2.0*sin(y[0] + y[1]) + 3.2*cos(y[0] + y[1]))*sin(x[0] + x[1]);
    return result; 
}

double dya10(vector<double> x, vector<double> y){
    double result = (2.0*pow(y[0], 3)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*cos(y[0] + y[1]) + 6.1*y[0]*sin(y[0] + y[1]) + 12.0*y[0]*cos(y[0] + y[1]) + 1.1*y[1]*sin(y[0] + y[1]) - 3.2*sin(y[0] + y[1]) - 8.1*cos(y[0] + y[1]))*cos(x[0] + x[1]);
    return result; 
}

double dya11(vector<double> x, vector<double> y){
    double result = (2.0*pow(y[0], 3)*sin(y[0] + y[1]) - 6.0*pow(y[0], 2)*sin(y[0] + y[1]) + 6.1*y[0]*sin(y[0] + y[1]) + 1.1*y[1]*sin(y[0] + y[1]) - 3.2*sin(y[0] + y[1]) - 3.1*cos(y[0] + y[1]))*cos(x[0] + x[1]);
    return result; 
}

double dyv0(vector<double> x, vector<double> y){
    double result = 0.1*y[1] + 2.0*pow(y[0] - 1, 3) - 0.1;
    return result; 
}

double h0(vector<double> x, vector<double> y){
    double result = 0;
    return result; 
}

double dyv1(vector<double> x, vector<double> y){
    double result = 0.1*y[0] + 1.0*y[1] - 1.1;
    return result; 
}

double h1(vector<double> x, vector<double> y){
    double result = 0;
    return result; 
}

double drif0(vector<double> x, vector<double> y){
    double result = -0.1*y[1] - 2.0*pow(y[0] - 1, 3) + 0.1;
    return result; 
}

double diff0(vector<double> x, vector<double> y){
    double result = sqrt(2);
    return result; 
}

double drif1(vector<double> x, vector<double> y){
    double result = -0.1*y[0] - 1.0*y[1] + 1.1;
    return result; 
}

double diff1(vector<double> x, vector<double> y){
    double result = sqrt(2);
    return result; 
}

double drif2(vector<double> x, vector<double> y){
    double result = 0 - 0.1*y[0] - 1.0*y[1];
    return result; 
}

double diff2(vector<double> x, vector<double> y){
    double result = sqrt(2);
    return result; 
}

double drif3(vector<double> x, vector<double> y){
    double result = 0 - 0.1*y[0] - 1.0*y[1];
    return result; 
}

double diff3(vector<double> x, vector<double> y){
    double result = sqrt(2);
    return result; 
}

void Problem::init_functions() {

    stardiv_h = stardiv_h_n;

    rho = rho_n;

    linearTerm = linearTerm_n;

    potential = potential_n;

    dyv[0] = dyv0;
    dyv[1] = dyv1;

    h[0] = h0;
    h[1] = h1;

    a[0] = a0;
    a[1] = a1;

    dxa[0][0] = dxa00;
    dxa[0][1] = dxa01;
    dxa[1][0] = dxa10;
    dxa[1][1] = dxa11;

    dya[0][0] = dya00;
    dya[0][1] = dya01;
    dya[1][0] = dya10;
    dya[1][1] = dya11;

    phi[0] = phi0;
    phi[1] = phi1;

    dxphi[0][0] = dxphi00;
    dxphi[0][1] = dxphi01;
    dxphi[1][0] = dxphi10;
    dxphi[1][1] = dxphi11;

    drif[0] = drif0;
    drif[1] = drif1;
    drif[2] = drif2;
    drif[3] = drif3;

    diff[0] = diff0;
    diff[1] = diff1;
    diff[2] = diff2;
    diff[3] = diff3;

}